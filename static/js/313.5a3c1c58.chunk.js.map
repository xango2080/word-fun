{"version":3,"file":"static/js/313.5a3c1c58.chunk.js","mappings":"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","sources":["../node_modules/web-vitals/dist/modules/lib/generateUniqueID.js","../node_modules/web-vitals/dist/modules/lib/polyfills/firstInputPolyfill.js","../node_modules/web-vitals/dist/modules/lib/initMetric.js","../node_modules/web-vitals/dist/modules/lib/observe.js","../node_modules/web-vitals/dist/modules/lib/onHidden.js","../node_modules/web-vitals/dist/modules/lib/onBFCacheRestore.js","../node_modules/web-vitals/dist/modules/lib/bindReporter.js","../node_modules/web-vitals/dist/modules/lib/getVisibilityWatcher.js","../node_modules/web-vitals/dist/modules/getFCP.js","../node_modules/web-vitals/dist/modules/getCLS.js","../node_modules/web-vitals/dist/modules/getFID.js","../node_modules/web-vitals/dist/modules/getLCP.js","../node_modules/web-vitals/dist/modules/getTTFB.js"],"sourcesContent":["/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Performantly generate a unique, 30-char string by combining a version\n * number, the current timestamp with a 13-digit number integer.\n * @return {string}\n */\nexport const generateUniqueID = () => {\n    return `v2-${Date.now()}-${Math.floor(Math.random() * (9e12 - 1)) + 1e12}`;\n};\n","/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nlet firstInputEvent;\nlet firstInputDelay;\nlet firstInputTimeStamp;\nlet callbacks;\nconst listenerOpts = { passive: true, capture: true };\nconst startTimeStamp = new Date();\n/**\n * Accepts a callback to be invoked once the first input delay and event\n * are known.\n */\nexport const firstInputPolyfill = (onFirstInput) => {\n    callbacks.push(onFirstInput);\n    reportFirstInputDelayIfRecordedAndValid();\n};\nexport const resetFirstInputPolyfill = () => {\n    callbacks = [];\n    firstInputDelay = -1;\n    firstInputEvent = null;\n    eachEventType(addEventListener);\n};\n/**\n * Records the first input delay and event, so subsequent events can be\n * ignored. All added event listeners are then removed.\n */\nconst recordFirstInputDelay = (delay, event) => {\n    if (!firstInputEvent) {\n        firstInputEvent = event;\n        firstInputDelay = delay;\n        firstInputTimeStamp = new Date;\n        eachEventType(removeEventListener);\n        reportFirstInputDelayIfRecordedAndValid();\n    }\n};\n/**\n * Reports the first input delay and event (if they're recorded and valid)\n * by running the array of callback functions.\n */\nconst reportFirstInputDelayIfRecordedAndValid = () => {\n    // In some cases the recorded delay is clearly wrong, e.g. it's negative\n    // or it's larger than the delta between now and initialization.\n    // - https://github.com/GoogleChromeLabs/first-input-delay/issues/4\n    // - https://github.com/GoogleChromeLabs/first-input-delay/issues/6\n    // - https://github.com/GoogleChromeLabs/first-input-delay/issues/7\n    if (firstInputDelay >= 0 &&\n        // @ts-ignore (subtracting two dates always returns a number)\n        firstInputDelay < firstInputTimeStamp - startTimeStamp) {\n        const entry = {\n            entryType: 'first-input',\n            name: firstInputEvent.type,\n            target: firstInputEvent.target,\n            cancelable: firstInputEvent.cancelable,\n            startTime: firstInputEvent.timeStamp,\n            processingStart: firstInputEvent.timeStamp + firstInputDelay,\n        };\n        callbacks.forEach(function (callback) {\n            callback(entry);\n        });\n        callbacks = [];\n    }\n};\n/**\n * Handles pointer down events, which are a special case.\n * Pointer events can trigger main or compositor thread behavior.\n * We differentiate these cases based on whether or not we see a\n * 'pointercancel' event, which are fired when we scroll. If we're scrolling\n * we don't need to report input delay since FID excludes scrolling and\n * pinch/zooming.\n */\nconst onPointerDown = (delay, event) => {\n    /**\n     * Responds to 'pointerup' events and records a delay. If a pointer up event\n     * is the next event after a pointerdown event, then it's not a scroll or\n     * a pinch/zoom.\n     */\n    const onPointerUp = () => {\n        recordFirstInputDelay(delay, event);\n        removePointerEventListeners();\n    };\n    /**\n     * Responds to 'pointercancel' events and removes pointer listeners.\n     * If a 'pointercancel' is the next event to fire after a pointerdown event,\n     * it means this is a scroll or pinch/zoom interaction.\n     */\n    const onPointerCancel = () => {\n        removePointerEventListeners();\n    };\n    /**\n     * Removes added pointer event listeners.\n     */\n    const removePointerEventListeners = () => {\n        removeEventListener('pointerup', onPointerUp, listenerOpts);\n        removeEventListener('pointercancel', onPointerCancel, listenerOpts);\n    };\n    addEventListener('pointerup', onPointerUp, listenerOpts);\n    addEventListener('pointercancel', onPointerCancel, listenerOpts);\n};\n/**\n * Handles all input events and records the time between when the event\n * was received by the operating system and when it's JavaScript listeners\n * were able to run.\n */\nconst onInput = (event) => {\n    // Only count cancelable events, which should trigger behavior\n    // important to the user.\n    if (event.cancelable) {\n        // In some browsers `event.timeStamp` returns a `DOMTimeStamp` value\n        // (epoch time) instead of the newer `DOMHighResTimeStamp`\n        // (document-origin time). To check for that we assume any timestamp\n        // greater than 1 trillion is a `DOMTimeStamp`, and compare it using\n        // the `Date` object rather than `performance.now()`.\n        // - https://github.com/GoogleChromeLabs/first-input-delay/issues/4\n        const isEpochTime = event.timeStamp > 1e12;\n        const now = isEpochTime ? new Date : performance.now();\n        // Input delay is the delta between when the system received the event\n        // (e.g. event.timeStamp) and when it could run the callback (e.g. `now`).\n        const delay = now - event.timeStamp;\n        if (event.type == 'pointerdown') {\n            onPointerDown(delay, event);\n        }\n        else {\n            recordFirstInputDelay(delay, event);\n        }\n    }\n};\n/**\n * Invokes the passed callback const for =  each event type with t =>he\n * `onInput` const and =  `listenerOpts =>`.\n */\nconst eachEventType = (callback) => {\n    const eventTypes = [\n        'mousedown',\n        'keydown',\n        'touchstart',\n        'pointerdown',\n    ];\n    eventTypes.forEach((type) => callback(type, onInput, listenerOpts));\n};\n","/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { generateUniqueID } from './generateUniqueID.js';\nexport const initMetric = (name, value) => {\n    return {\n        name,\n        value: typeof value === 'undefined' ? -1 : value,\n        delta: 0,\n        entries: [],\n        id: generateUniqueID()\n    };\n};\n","/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Takes a performance entry type and a callback function, and creates a\n * `PerformanceObserver` instance that will observe the specified entry type\n * with buffering enabled and call the callback _for each entry_.\n *\n * This function also feature-detects entry support and wraps the logic in a\n * try/catch to avoid errors in unsupporting browsers.\n */\nexport const observe = (type, callback) => {\n    try {\n        if (PerformanceObserver.supportedEntryTypes.includes(type)) {\n            // More extensive feature detect needed for Firefox due to:\n            // https://github.com/GoogleChrome/web-vitals/issues/142\n            if (type === 'first-input' && !('PerformanceEventTiming' in self)) {\n                return;\n            }\n            const po = new PerformanceObserver((l) => l.getEntries().map(callback));\n            po.observe({ type, buffered: true });\n            return po;\n        }\n    }\n    catch (e) {\n        // Do nothing.\n    }\n    return;\n};\n","/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport const onHidden = (cb, once) => {\n    const onHiddenOrPageHide = (event) => {\n        if (event.type === 'pagehide' || document.visibilityState === 'hidden') {\n            cb(event);\n            if (once) {\n                removeEventListener('visibilitychange', onHiddenOrPageHide, true);\n                removeEventListener('pagehide', onHiddenOrPageHide, true);\n            }\n        }\n    };\n    addEventListener('visibilitychange', onHiddenOrPageHide, true);\n    // Some browsers have buggy implementations of visibilitychange,\n    // so we use pagehide in addition, just to be safe.\n    addEventListener('pagehide', onHiddenOrPageHide, true);\n};\n","/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport const onBFCacheRestore = (cb) => {\n    addEventListener('pageshow', (event) => {\n        if (event.persisted) {\n            cb(event);\n        }\n    }, true);\n};\n","/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport const bindReporter = (callback, metric, reportAllChanges) => {\n    let prevValue;\n    return (forceReport) => {\n        if (metric.value >= 0) {\n            if (forceReport || reportAllChanges) {\n                metric.delta = metric.value - (prevValue || 0);\n                // Report the metric if there's a non-zero delta or if no previous\n                // value exists (which can happen in the case of the document becoming\n                // hidden when the metric value is 0).\n                // See: https://github.com/GoogleChrome/web-vitals/issues/14\n                if (metric.delta || prevValue === undefined) {\n                    prevValue = metric.value;\n                    callback(metric);\n                }\n            }\n        }\n    };\n};\n","/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { onBFCacheRestore } from './onBFCacheRestore.js';\nimport { onHidden } from './onHidden.js';\nlet firstHiddenTime = -1;\nconst initHiddenTime = () => {\n    return document.visibilityState === 'hidden' ? 0 : Infinity;\n};\nconst trackChanges = () => {\n    // Update the time if/when the document becomes hidden.\n    onHidden(({ timeStamp }) => {\n        firstHiddenTime = timeStamp;\n    }, true);\n};\nexport const getVisibilityWatcher = () => {\n    if (firstHiddenTime < 0) {\n        // If the document is hidden when this code runs, assume it was hidden\n        // since navigation start. This isn't a perfect heuristic, but it's the\n        // best we can do until an API is available to support querying past\n        // visibilityState.\n        if (window.__WEB_VITALS_POLYFILL__) {\n            firstHiddenTime = window.webVitals.firstHiddenTime;\n            if (firstHiddenTime === Infinity) {\n                trackChanges();\n            }\n        }\n        else {\n            firstHiddenTime = initHiddenTime();\n            trackChanges();\n        }\n        // Reset the time on bfcache restores.\n        onBFCacheRestore(() => {\n            // Schedule a task in order to track the `visibilityState` once it's\n            // had an opportunity to change to visible in all browsers.\n            // https://bugs.chromium.org/p/chromium/issues/detail?id=1133363\n            setTimeout(() => {\n                firstHiddenTime = initHiddenTime();\n                trackChanges();\n            }, 0);\n        });\n    }\n    return {\n        get firstHiddenTime() {\n            return firstHiddenTime;\n        }\n    };\n};\n","/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { bindReporter } from './lib/bindReporter.js';\nimport { getVisibilityWatcher } from './lib/getVisibilityWatcher.js';\nimport { initMetric } from './lib/initMetric.js';\nimport { observe } from './lib/observe.js';\nimport { onBFCacheRestore } from './lib/onBFCacheRestore.js';\nexport const getFCP = (onReport, reportAllChanges) => {\n    const visibilityWatcher = getVisibilityWatcher();\n    let metric = initMetric('FCP');\n    let report;\n    const entryHandler = (entry) => {\n        if (entry.name === 'first-contentful-paint') {\n            if (po) {\n                po.disconnect();\n            }\n            // Only report if the page wasn't hidden prior to the first paint.\n            if (entry.startTime < visibilityWatcher.firstHiddenTime) {\n                metric.value = entry.startTime;\n                metric.entries.push(entry);\n                report(true);\n            }\n        }\n    };\n    // TODO(philipwalton): remove the use of `fcpEntry` once this bug is fixed.\n    // https://bugs.webkit.org/show_bug.cgi?id=225305\n    // The check for `getEntriesByName` is needed to support Opera:\n    // https://github.com/GoogleChrome/web-vitals/issues/159\n    // The check for `window.performance` is needed to support Opera mini:\n    // https://github.com/GoogleChrome/web-vitals/issues/185\n    const fcpEntry = window.performance && performance.getEntriesByName &&\n        performance.getEntriesByName('first-contentful-paint')[0];\n    const po = fcpEntry ? null : observe('paint', entryHandler);\n    if (fcpEntry || po) {\n        report = bindReporter(onReport, metric, reportAllChanges);\n        if (fcpEntry) {\n            entryHandler(fcpEntry);\n        }\n        onBFCacheRestore((event) => {\n            metric = initMetric('FCP');\n            report = bindReporter(onReport, metric, reportAllChanges);\n            requestAnimationFrame(() => {\n                requestAnimationFrame(() => {\n                    metric.value = performance.now() - event.timeStamp;\n                    report(true);\n                });\n            });\n        });\n    }\n};\n","/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { initMetric } from './lib/initMetric.js';\nimport { observe } from './lib/observe.js';\nimport { onHidden } from './lib/onHidden.js';\nimport { onBFCacheRestore } from './lib/onBFCacheRestore.js';\nimport { bindReporter } from './lib/bindReporter.js';\nimport { getFCP } from './getFCP.js';\nlet isMonitoringFCP = false;\nlet fcpValue = -1;\nexport const getCLS = (onReport, reportAllChanges) => {\n    // Start monitoring FCP so we can only report CLS if FCP is also reported.\n    // Note: this is done to match the current behavior of CrUX.\n    if (!isMonitoringFCP) {\n        getFCP((metric) => {\n            fcpValue = metric.value;\n        });\n        isMonitoringFCP = true;\n    }\n    const onReportWrapped = (arg) => {\n        if (fcpValue > -1) {\n            onReport(arg);\n        }\n    };\n    let metric = initMetric('CLS', 0);\n    let report;\n    let sessionValue = 0;\n    let sessionEntries = [];\n    const entryHandler = (entry) => {\n        // Only count layout shifts without recent user input.\n        if (!entry.hadRecentInput) {\n            const firstSessionEntry = sessionEntries[0];\n            const lastSessionEntry = sessionEntries[sessionEntries.length - 1];\n            // If the entry occurred less than 1 second after the previous entry and\n            // less than 5 seconds after the first entry in the session, include the\n            // entry in the current session. Otherwise, start a new session.\n            if (sessionValue &&\n                entry.startTime - lastSessionEntry.startTime < 1000 &&\n                entry.startTime - firstSessionEntry.startTime < 5000) {\n                sessionValue += entry.value;\n                sessionEntries.push(entry);\n            }\n            else {\n                sessionValue = entry.value;\n                sessionEntries = [entry];\n            }\n            // If the current session value is larger than the current CLS value,\n            // update CLS and the entries contributing to it.\n            if (sessionValue > metric.value) {\n                metric.value = sessionValue;\n                metric.entries = sessionEntries;\n                report();\n            }\n        }\n    };\n    const po = observe('layout-shift', entryHandler);\n    if (po) {\n        report = bindReporter(onReportWrapped, metric, reportAllChanges);\n        onHidden(() => {\n            po.takeRecords().map(entryHandler);\n            report(true);\n        });\n        onBFCacheRestore(() => {\n            sessionValue = 0;\n            fcpValue = -1;\n            metric = initMetric('CLS', 0);\n            report = bindReporter(onReportWrapped, metric, reportAllChanges);\n        });\n    }\n};\n","/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { bindReporter } from './lib/bindReporter.js';\nimport { getVisibilityWatcher } from './lib/getVisibilityWatcher.js';\nimport { initMetric } from './lib/initMetric.js';\nimport { observe } from './lib/observe.js';\nimport { onBFCacheRestore } from './lib/onBFCacheRestore.js';\nimport { onHidden } from './lib/onHidden.js';\nimport { firstInputPolyfill, resetFirstInputPolyfill } from './lib/polyfills/firstInputPolyfill.js';\nexport const getFID = (onReport, reportAllChanges) => {\n    const visibilityWatcher = getVisibilityWatcher();\n    let metric = initMetric('FID');\n    let report;\n    const entryHandler = (entry) => {\n        // Only report if the page wasn't hidden prior to the first input.\n        if (entry.startTime < visibilityWatcher.firstHiddenTime) {\n            metric.value = entry.processingStart - entry.startTime;\n            metric.entries.push(entry);\n            report(true);\n        }\n    };\n    const po = observe('first-input', entryHandler);\n    report = bindReporter(onReport, metric, reportAllChanges);\n    if (po) {\n        onHidden(() => {\n            po.takeRecords().map(entryHandler);\n            po.disconnect();\n        }, true);\n    }\n    if (window.__WEB_VITALS_POLYFILL__) {\n        // Prefer the native implementation if available,\n        if (!po) {\n            window.webVitals.firstInputPolyfill(entryHandler);\n        }\n        onBFCacheRestore(() => {\n            metric = initMetric('FID');\n            report = bindReporter(onReport, metric, reportAllChanges);\n            window.webVitals.resetFirstInputPolyfill();\n            window.webVitals.firstInputPolyfill(entryHandler);\n        });\n    }\n    else {\n        // Only monitor bfcache restores if the browser supports FID natively.\n        if (po) {\n            onBFCacheRestore(() => {\n                metric = initMetric('FID');\n                report = bindReporter(onReport, metric, reportAllChanges);\n                resetFirstInputPolyfill();\n                firstInputPolyfill(entryHandler);\n            });\n        }\n    }\n};\n","/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { bindReporter } from './lib/bindReporter.js';\nimport { getVisibilityWatcher } from './lib/getVisibilityWatcher.js';\nimport { initMetric } from './lib/initMetric.js';\nimport { observe } from './lib/observe.js';\nimport { onBFCacheRestore } from './lib/onBFCacheRestore.js';\nimport { onHidden } from './lib/onHidden.js';\nconst reportedMetricIDs = {};\nexport const getLCP = (onReport, reportAllChanges) => {\n    const visibilityWatcher = getVisibilityWatcher();\n    let metric = initMetric('LCP');\n    let report;\n    const entryHandler = (entry) => {\n        // The startTime attribute returns the value of the renderTime if it is not 0,\n        // and the value of the loadTime otherwise.\n        const value = entry.startTime;\n        // If the page was hidden prior to paint time of the entry,\n        // ignore it and mark the metric as final, otherwise add the entry.\n        if (value < visibilityWatcher.firstHiddenTime) {\n            metric.value = value;\n            metric.entries.push(entry);\n            report();\n        }\n    };\n    const po = observe('largest-contentful-paint', entryHandler);\n    if (po) {\n        report = bindReporter(onReport, metric, reportAllChanges);\n        const stopListening = () => {\n            if (!reportedMetricIDs[metric.id]) {\n                po.takeRecords().map(entryHandler);\n                po.disconnect();\n                reportedMetricIDs[metric.id] = true;\n                report(true);\n            }\n        };\n        // Stop listening after input. Note: while scrolling is an input that\n        // stop LCP observation, it's unreliable since it can be programmatically\n        // generated. See: https://github.com/GoogleChrome/web-vitals/issues/75\n        ['keydown', 'click'].forEach((type) => {\n            addEventListener(type, stopListening, { once: true, capture: true });\n        });\n        onHidden(stopListening, true);\n        onBFCacheRestore((event) => {\n            metric = initMetric('LCP');\n            report = bindReporter(onReport, metric, reportAllChanges);\n            requestAnimationFrame(() => {\n                requestAnimationFrame(() => {\n                    metric.value = performance.now() - event.timeStamp;\n                    reportedMetricIDs[metric.id] = true;\n                    report(true);\n                });\n            });\n        });\n    }\n};\n","/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { initMetric } from './lib/initMetric.js';\nconst afterLoad = (callback) => {\n    if (document.readyState === 'complete') {\n        // Queue a task so the callback runs after `loadEventEnd`.\n        setTimeout(callback, 0);\n    }\n    else {\n        // Use `pageshow` so the callback runs after `loadEventEnd`.\n        addEventListener('pageshow', callback);\n    }\n};\nconst getNavigationEntryFromPerformanceTiming = () => {\n    // Really annoying that TypeScript errors when using `PerformanceTiming`.\n    const timing = performance.timing;\n    const navigationEntry = {\n        entryType: 'navigation',\n        startTime: 0,\n    };\n    for (const key in timing) {\n        if (key !== 'navigationStart' && key !== 'toJSON') {\n            navigationEntry[key] = Math.max(timing[key] -\n                timing.navigationStart, 0);\n        }\n    }\n    return navigationEntry;\n};\nexport const getTTFB = (onReport) => {\n    const metric = initMetric('TTFB');\n    afterLoad(() => {\n        try {\n            // Use the NavigationTiming L2 entry if available.\n            const navigationEntry = performance.getEntriesByType('navigation')[0] ||\n                getNavigationEntryFromPerformanceTiming();\n            metric.value = metric.delta =\n                navigationEntry.responseStart;\n            // In some cases the value reported is negative or is larger\n            // than the current page time. Ignore these cases:\n            // https://github.com/GoogleChrome/web-vitals/issues/137\n            // https://github.com/GoogleChrome/web-vitals/issues/162\n            if (metric.value < 0 || metric.value > performance.now())\n                return;\n            metric.entries = [navigationEntry];\n            onReport(metric);\n        }\n        catch (error) {\n            // Do nothing.\n        }\n    });\n};\n"],"names":["firstInputEvent","firstInputDelay","firstInputTimeStamp","callbacks","initMetric","name","value","delta","entries","id","Date","now","Math","floor","random","observe","type","callback","PerformanceObserver","supportedEntryTypes","includes","self","po","l","getEntries","map","buffered","e","onHidden","cb","once","onHiddenOrPageHide","event","document","visibilityState","removeEventListener","addEventListener","onBFCacheRestore","persisted","bindReporter","metric","reportAllChanges","prevValue","forceReport","undefined","firstHiddenTime","initHiddenTime","Infinity","trackChanges","timeStamp","getVisibilityWatcher","window","__WEB_VITALS_POLYFILL__","webVitals","setTimeout","getFCP","onReport","report","visibilityWatcher","entryHandler","entry","disconnect","startTime","push","fcpEntry","performance","getEntriesByName","requestAnimationFrame","isMonitoringFCP","fcpValue","getCLS","onReportWrapped","arg","sessionValue","sessionEntries","hadRecentInput","firstSessionEntry","lastSessionEntry","length","takeRecords","listenerOpts","passive","capture","startTimeStamp","recordFirstInputDelay","delay","eachEventType","reportFirstInputDelayIfRecordedAndValid","entryType","target","cancelable","processingStart","forEach","onInput","onPointerUp","removePointerEventListeners","onPointerCancel","onPointerDown","getFID","firstInputPolyfill","resetFirstInputPolyfill","onFirstInput","reportedMetricIDs","getLCP","stopListening","getTTFB","navigationEntry","getEntriesByType","timing","key","max","navigationStart","getNavigationEntryFromPerformanceTiming","responseStart","error","readyState"],"sourceRoot":""}